-- File automatically generated by "cdfg2hdl".
-- Filename: cordic.vhd
-- Date: 27 November 2010 08:42:54 PM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013, 2014, 2015,
--                                2016

library IEEE;
use WORK.operpack.all;
use WORK.cordic_cdt_pkg.all;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;


entity cordic is
  port (
    clk : in std_logic;
    reset : in std_logic;
    start : in std_logic;
    direction : in std_logic_vector(15 downto 0);
    mode : in std_logic_vector(15 downto 0);
    xin : in std_logic_vector(15 downto 0);
    yin : in std_logic_vector(15 downto 0);
    zin : in std_logic_vector(15 downto 0);
    xout : out std_logic_vector(15 downto 0);
    yout : out std_logic_vector(15 downto 0);
    zout : out std_logic_vector(15 downto 0);
    done : out std_logic;
    ready : out std_logic
  );
end cordic;

architecture fsmd of cordic is
  type state_type is (S_ENTRY, S_EXIT, S_001_001, S_002_001, S_003_001, S_004_001);
  signal current_state, next_state: state_type;
  signal cordic_hyp_steps : cordic_hyp_steps_type := (
    14 => "0000000000001101",
    13 => "0000000000001101",
    12 => "0000000000001100",
    11 => "0000000000001011",
    10 => "0000000000001010",
    9 => "0000000000001001",
    8 => "0000000000001000",
    7 => "0000000000000111",
    6 => "0000000000000110",
    5 => "0000000000000101",
    4 => "0000000000000100",
    3 => "0000000000000100",
    2 => "0000000000000011",
    1 => "0000000000000010",
    0 => "0000000000000001",
    others => (others => '0'));
  signal cordic_tab : cordic_tab_type := (
    41 => "0000000000000001",
    40 => "0000000000000011",
    39 => "0000000000000111",
    38 => "0000000000001111",
    37 => "0000000000011111",
    36 => "0000000000111111",
    35 => "0000000001111111",
    34 => "0000000011111111",
    33 => "0000000111111111",
    32 => "0000001111111110",
    31 => "0000011111110101",
    30 => "0000111110101101",
    29 => "0001110110101100",
    28 => "0011001001000011",
    27 => "0000000000000010",
    26 => "0000000000000100",
    25 => "0000000000001000",
    24 => "0000000000010000",
    23 => "0000000000100000",
    22 => "0000000001000000",
    21 => "0000000010000000",
    20 => "0000000100000000",
    19 => "0000001000000000",
    18 => "0000010000000000",
    17 => "0000100000000000",
    16 => "0001000000000000",
    15 => "0010000000000000",
    14 => "0100000000000000",
    13 => "0000000000000010",
    12 => "0000000000000100",
    11 => "0000000000001000",
    10 => "0000000000010000",
    9 => "0000000000100000",
    8 => "0000000001000000",
    7 => "0000000010000000",
    6 => "0000000100000000",
    5 => "0000001000000000",
    4 => "0000010000000001",
    3 => "0000100000001010",
    2 => "0001000001011000",
    1 => "0010001100100111",
    0 => "1111111111111111",
    others => (others => '0'));
  signal t5_next : std_logic_vector(15 downto 0);
  signal t5_reg : std_logic_vector(15 downto 0);
  signal x2_next : std_logic_vector(15 downto 0);
  signal x2_reg : std_logic_vector(15 downto 0);
  signal y1_next : std_logic_vector(15 downto 0);
  signal y1_reg : std_logic_vector(15 downto 0);
  signal z2_next : std_logic_vector(15 downto 0);
  signal z2_reg : std_logic_vector(15 downto 0);
  signal k_next : std_logic_vector(15 downto 0);
  signal k_reg : std_logic_vector(15 downto 0);
  signal zero_next : std_logic_vector(15 downto 0);
  signal zero_reg : std_logic_vector(15 downto 0);
  signal one_next : std_logic_vector(15 downto 0);
  signal one_reg : std_logic_vector(15 downto 0);
  signal t1_next : std_logic_vector(15 downto 0);
  signal t1_reg : std_logic_vector(15 downto 0);
  signal tabval_next : std_logic_vector(15 downto 0);
  signal tabval_reg : std_logic_vector(15 downto 0);
  signal x_next : std_logic_vector(15 downto 0);
  signal x_reg : std_logic_vector(15 downto 0);
  signal y_next : std_logic_vector(15 downto 0);
  signal y_reg : std_logic_vector(15 downto 0);
  signal z_next : std_logic_vector(15 downto 0);
  signal z_reg : std_logic_vector(15 downto 0);
  signal ldirection_next : std_logic_vector(15 downto 0);
  signal ldirection_reg : std_logic_vector(15 downto 0);
  signal lmode_next : std_logic_vector(15 downto 0);
  signal lmode_reg : std_logic_vector(15 downto 0);
  signal t4_next : std_logic_vector(15 downto 0);
  signal t4_reg : std_logic_vector(15 downto 0);
  signal ybyk_next : std_logic_vector(15 downto 0);
  signal ybyk_reg : std_logic_vector(15 downto 0);
  signal t7_next : std_logic_vector(15 downto 0);
  signal t7_reg : std_logic_vector(15 downto 0);
  signal d_next : std_logic_vector(15 downto 0);
  signal d_reg : std_logic_vector(15 downto 0);
  signal t0_next : std_logic_vector(15 downto 0);
  signal t0_reg : std_logic_vector(15 downto 0);
  signal offset_next : std_logic_vector(15 downto 0);
  signal offset_reg : std_logic_vector(15 downto 0);
  signal kfinal_next : std_logic_vector(15 downto 0);
  signal kfinal_reg : std_logic_vector(15 downto 0);
  signal kk_next : std_logic_vector(15 downto 0);
  signal kk_reg : std_logic_vector(15 downto 0);
  signal t9_next : std_logic_vector(15 downto 0);
  signal t9_reg : std_logic_vector(15 downto 0);
  signal t3_next : std_logic_vector(15 downto 0);
  signal t3_reg : std_logic_vector(15 downto 0);
  signal t2_next : std_logic_vector(15 downto 0);
  signal t2_reg : std_logic_vector(15 downto 0);
  signal xbyk_next : std_logic_vector(15 downto 0);
  signal xbyk_reg : std_logic_vector(15 downto 0);
  signal t6_next : std_logic_vector(15 downto 0);
  signal t6_reg : std_logic_vector(15 downto 0);
  signal t8_next : std_logic_vector(15 downto 0);
  signal t8_reg : std_logic_vector(15 downto 0);
  signal x1_next : std_logic_vector(15 downto 0);
  signal x1_reg : std_logic_vector(15 downto 0);
  signal y2_next : std_logic_vector(15 downto 0);
  signal y2_reg : std_logic_vector(15 downto 0);
  signal z1_next : std_logic_vector(15 downto 0);
  signal z1_reg : std_logic_vector(15 downto 0);
  signal zout_next : std_logic_vector(15 downto 0);
  signal zout_reg : std_logic_vector(15 downto 0);
  signal yout_next : std_logic_vector(15 downto 0);
  signal yout_reg : std_logic_vector(15 downto 0);
  signal xout_next : std_logic_vector(15 downto 0);
  signal xout_reg : std_logic_vector(15 downto 0);
  constant CNST_28 : std_logic_vector(15 downto 0) := "0000000000011100";
  constant CNST_2 : std_logic_vector(15 downto 0) := "0000000000000010";
  constant CNST_15 : std_logic_vector(15 downto 0) := "0000000000001111";
  constant CNST_14 : std_logic_vector(15 downto 0) := "0000000000001110";
  constant CNST_1 : std_logic_vector(15 downto 0) := "0000000000000001";
  constant CNST_0 : std_logic_vector(15 downto 0) := "0000000000000000";
begin
  -- current state logic
  process (clk, reset)
  begin
    if (reset = '1') then
      current_state <= S_ENTRY;
      t5_reg <= (others => '0');
      x2_reg <= (others => '0');
      y1_reg <= (others => '0');
      z2_reg <= (others => '0');
      k_reg <= (others => '0');
      zero_reg <= (others => '0');
      one_reg <= (others => '0');
      t1_reg <= (others => '0');
      tabval_reg <= (others => '0');
      x_reg <= (others => '0');
      y_reg <= (others => '0');
      z_reg <= (others => '0');
      ldirection_reg <= (others => '0');
      lmode_reg <= (others => '0');
      t4_reg <= (others => '0');
      ybyk_reg <= (others => '0');
      t7_reg <= (others => '0');
      d_reg <= (others => '0');
      t0_reg <= (others => '0');
      offset_reg <= (others => '0');
      kfinal_reg <= (others => '0');
      kk_reg <= (others => '0');
      t9_reg <= (others => '0');
      t3_reg <= (others => '0');
      t2_reg <= (others => '0');
      xbyk_reg <= (others => '0');
      t6_reg <= (others => '0');
      t8_reg <= (others => '0');
      x1_reg <= (others => '0');
      y2_reg <= (others => '0');
      z1_reg <= (others => '0');
      zout_reg <= (others => '0');
      yout_reg <= (others => '0');
      xout_reg <= (others => '0');
    elsif (clk = '1' and clk'EVENT) then
      current_state <= next_state;
      t5_reg <= t5_next;
      x2_reg <= x2_next;
      y1_reg <= y1_next;
      z2_reg <= z2_next;
      k_reg <= k_next;
      zero_reg <= zero_next;
      one_reg <= one_next;
      t1_reg <= t1_next;
      tabval_reg <= tabval_next;
      x_reg <= x_next;
      y_reg <= y_next;
      z_reg <= z_next;
      ldirection_reg <= ldirection_next;
      lmode_reg <= lmode_next;
      t4_reg <= t4_next;
      ybyk_reg <= ybyk_next;
      t7_reg <= t7_next;
      d_reg <= d_next;
      t0_reg <= t0_next;
      offset_reg <= offset_next;
      kfinal_reg <= kfinal_next;
      kk_reg <= kk_next;
      t9_reg <= t9_next;
      t3_reg <= t3_next;
      t2_reg <= t2_next;
      xbyk_reg <= xbyk_next;
      t6_reg <= t6_next;
      t8_reg <= t8_next;
      x1_reg <= x1_next;
      y2_reg <= y2_next;
      z1_reg <= z1_next;
      zout_reg <= zout_next;
      yout_reg <= yout_next;
      xout_reg <= xout_next;
    end if;
  end process;

  -- next state and output logic
  process (current_state, start,
    direction,
    mode,
    xin,
    yin,
    zin,
    xout_reg,
    yout_reg,
    zout_reg,
    t5_reg, t5_next,
    x2_reg, x2_next,
    y1_reg, y1_next,
    z2_reg, z2_next,
    k_reg, k_next,
    zero_reg, zero_next,
    one_reg, one_next,
    t1_reg, t1_next,
    tabval_reg, tabval_next,
    x_reg, x_next,
    y_reg, y_next,
    z_reg, z_next,
    ldirection_reg, ldirection_next,
    lmode_reg, lmode_next,
    t4_reg, t4_next,
    ybyk_reg, ybyk_next,
    t7_reg, t7_next,
    d_reg, d_next,
    t0_reg, t0_next,
    offset_reg, offset_next,
    kfinal_reg, kfinal_next,
    kk_reg, kk_next,
    t9_reg, t9_next,
    t3_reg, t3_next,
    t2_reg, t2_next,
    xbyk_reg, xbyk_next,
    t6_reg, t6_next,
    t8_reg, t8_next,
    x1_reg, x1_next,
    y2_reg, y2_next,
    z1_reg, z1_next
  )
  begin
    done <= '0';
    ready <= '0';
    t5_next <= t5_reg;
    x2_next <= x2_reg;
    y1_next <= y1_reg;
    z2_next <= z2_reg;
    k_next <= k_reg;
    zero_next <= zero_reg;
    one_next <= one_reg;
    t1_next <= t1_reg;
    tabval_next <= tabval_reg;
    x_next <= x_reg;
    y_next <= y_reg;
    z_next <= z_reg;
    ldirection_next <= ldirection_reg;
    lmode_next <= lmode_reg;
    t4_next <= t4_reg;
    ybyk_next <= ybyk_reg;
    t7_next <= t7_reg;
    d_next <= d_reg;
    t0_next <= t0_reg;
    offset_next <= offset_reg;
    kfinal_next <= kfinal_reg;
    kk_next <= kk_reg;
    t9_next <= t9_reg;
    t3_next <= t3_reg;
    t2_next <= t2_reg;
    xbyk_next <= xbyk_reg;
    t6_next <= t6_reg;
    t8_next <= t8_reg;
    x1_next <= x1_reg;
    y2_next <= y2_reg;
    z1_next <= z1_reg;
    zout_next <= zout_reg;
    yout_next <= yout_reg;
    xout_next <= xout_reg;
    case current_state is
      when S_ENTRY =>
        ready <= '1';
        if (start = '1') then
          next_state <= S_001_001;
        else
          next_state <= S_ENTRY;
        end if;
      when S_001_001 =>
        zero_next <= CNST_0(15 downto 0);
        one_next <= CNST_1(15 downto 0);
        x_next <= xin(15 downto 0);
        y_next <= yin(15 downto 0);
        z_next <= zin(15 downto 0);
        ldirection_next <= direction(15 downto 0);
        lmode_next <= mode(15 downto 0);
        k_next <= CNST_0(15 downto 0);
        if (lmode_next = CNST_1(15 downto 0)) then
          t0_next <= CNST_14(15 downto 0);
        else
          t0_next <= CNST_28(15 downto 0);
        end if;
        if (lmode_next = CNST_2(15 downto 0)) then
          offset_next <= CNST_0(15 downto 0);
        else
          offset_next <= t0_next(15 downto 0);
        end if;
        if (lmode_next = CNST_2(15 downto 0)) then
          kfinal_next <= CNST_15(15 downto 0);
        else
          kfinal_next <= CNST_14(15 downto 0);
        end if;
        next_state <= S_002_001;
      when S_002_001 =>
        if (k_reg < kfinal_reg(15 downto 0)) then
          next_state <= S_003_001;
        else
          next_state <= S_004_001;
        end if;
      when S_003_001 =>
        t1_next <= cordic_hyp_steps(to_integer(unsigned(k_reg(3 downto 0))));
        if (lmode_reg /= CNST_2(15 downto 0)) then
          kk_next <= k_reg(15 downto 0);
        else
          kk_next <= t1_next(15 downto 0);
        end if;
        t2_next <= shrv4(y_reg, kk_next, '1');
        t3_next <= std_logic_vector(not(unsigned(t2_next(15 downto 0))) + unsigned(ONE));
        xbyk_next <= shrv4(x_reg, kk_next, '1');
        if (lmode_reg = CNST_1(15 downto 0)) then
          t4_next <= zero_reg(15 downto 0);
        else
          t4_next <= t2_next(15 downto 0);
        end if;
        if (lmode_reg = CNST_2(15 downto 0)) then
          ybyk_next <= t3_next(15 downto 0);
        else
          ybyk_next <= t4_next(15 downto 0);
        end if;
        t5_next <= std_logic_vector(signed(kk_next) + signed(offset_reg(15 downto 0)));
        tabval_next <= cordic_tab(to_integer(unsigned(t5_next(5 downto 0))));
        t6_next(15 downto 1) <= (others => z_reg(15));
        t6_next(0 downto 0) <= z_reg(15 downto 15);
        if (t6_next = CNST_0(15 downto 0)) then
          t7_next <= zero_reg(15 downto 0);
        else
          t7_next <= one_reg(15 downto 0);
        end if;
        t8_next(15 downto 1) <= (others => y_reg(15));
        t8_next(0 downto 0) <= y_reg(15 downto 15);
        if (t8_next /= CNST_0(15 downto 0)) then
          t9_next <= zero_reg(15 downto 0);
        else
          t9_next <= one_reg(15 downto 0);
        end if;
        if (ldirection_reg = CNST_0(15 downto 0)) then
          d_next <= t7_next(15 downto 0);
        else
          d_next <= t9_next(15 downto 0);
        end if;
        x1_next <= std_logic_vector(signed(x_reg) - signed(ybyk_next(15 downto 0)));
        x2_next <= std_logic_vector(signed(x_reg) + signed(ybyk_next(15 downto 0)));
        y1_next <= std_logic_vector(signed(y_reg) + signed(xbyk_next(15 downto 0)));
        y2_next <= std_logic_vector(signed(y_reg) - signed(xbyk_next(15 downto 0)));
        z1_next <= std_logic_vector(signed(z_reg) - signed(tabval_next(15 downto 0)));
        z2_next <= std_logic_vector(signed(z_reg) + signed(tabval_next(15 downto 0)));
        if (d_next = CNST_0(15 downto 0)) then
          x_next <= x1_next(15 downto 0);
        else
          x_next <= x2_next(15 downto 0);
        end if;
        if (d_next = CNST_0(15 downto 0)) then
          y_next <= y1_next(15 downto 0);
        else
          y_next <= y2_next(15 downto 0);
        end if;
        if (d_next = CNST_0(15 downto 0)) then
          z_next <= z1_next(15 downto 0);
        else
          z_next <= z2_next(15 downto 0);
        end if;
        k_next <= std_logic_vector(signed(k_reg) + signed(CNST_1(15 downto 0)));
        if (k_next < kfinal_reg(15 downto 0)) then
          next_state <= S_003_001;
        else
          next_state <= S_004_001;
        end if;
      when S_004_001 =>
        xout_next <= x_reg(15 downto 0);
        yout_next <= y_reg(15 downto 0);
        zout_next <= z_reg(15 downto 0);
        next_state <= S_EXIT;
      when S_EXIT =>
        done <= '1';
        next_state <= S_ENTRY;
    end case;
  end process;

  zout <= zout_reg;
  yout <= yout_reg;
  xout <= xout_reg;

end fsmd;
