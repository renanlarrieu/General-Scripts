-- File automatically generated by "cdfg2hdl".
-- Filename: cordic_tb.vhd
-- Date: 08 November 2010 11:05:42 AM
-- Author: Nikolaos Kavvadias (C) 2009, 2010, 2011, 2012, 2013, 2014, 2015
--                                2016

library IEEE, STD;
use STD.textio.all;
use WORK.std_logic_textio.all;
use IEEE.numeric_std.all;
use WORK.cordic_cdt_pkg.all;
use IEEE.std_logic_1164.all;

entity cordic_tb is
end cordic_tb;

architecture tb_arch of cordic_tb is
  component cordic
    port (
      clk : in std_logic;
      reset : in std_logic;
      start : in std_logic;
      direction : in std_logic_vector(15 downto 0);
      mode : in std_logic_vector(15 downto 0);
      xin : in std_logic_vector(15 downto 0);
      yin : in std_logic_vector(15 downto 0);
      zin : in std_logic_vector(15 downto 0);
      xout : out std_logic_vector(15 downto 0);
      yout : out std_logic_vector(15 downto 0);
      zout : out std_logic_vector(15 downto 0);
      done : out std_logic;
      ready : out std_logic
    );
  end component;
  signal clk : std_logic;
  signal reset : std_logic;
  signal start : std_logic;
  signal direction : std_logic_vector(15 downto 0);
  signal mode : std_logic_vector(15 downto 0);
  signal xin : std_logic_vector(15 downto 0);
  signal yin : std_logic_vector(15 downto 0);
  signal zin : std_logic_vector(15 downto 0);
  signal xout : std_logic_vector(15 downto 0);
  signal yout : std_logic_vector(15 downto 0);
  signal zout : std_logic_vector(15 downto 0);
  signal done : std_logic;
  signal ready : std_logic;
  -- Profiling signals
  signal ncycles : integer;
  -- Constant declarations
  constant CLK_PERIOD : time := 10 ns;
  -- Declare test data file and results file
  file TestDataFile: text open read_mode is "cordic_test_data.txt";
  file ResultsFile: text open write_mode is "cordic_alg_test_results.txt";
begin
  uut : cordic
    port map (
      clk => clk,
      reset => reset,
      start => start,
      direction => direction,
      mode => mode,
      xin => xin,
      yin => yin,
      zin => zin,
      xout => xout,
      yout => yout,
      zout => zout,
      ready => ready,
      done => done
    );

  CLK_GEN_PROC: process(clk)
  begin
    if (clk = 'U') then
      clk <= '1';
    else
      clk <= not clk after CLK_PERIOD/2;
    end if;
  end process CLK_GEN_PROC;

  RESET_START_STIM: process
  begin
    reset <= '1';
    start <= '0';
    wait for CLK_PERIOD;
    reset <= '0';
    start <= '1';
    wait for 536870911*CLK_PERIOD;
  end process RESET_START_STIM;

  PROFILING: process(clk, reset, done)
  begin
    if (reset = '1' or done = '1') then
      ncycles <= 0;
    elsif (clk = '1' and clk'EVENT) then
      ncycles <= ncycles + 1;
    end if;
  end process PROFILING;

  CORDIC_BENCH: process
    variable direction_v : signed(15 downto 0);
    variable direction_v_vec : std_logic_vector(15 downto 0);
    variable mode_v : signed(15 downto 0);
    variable mode_v_vec : std_logic_vector(15 downto 0);
    variable xin_v : signed(15 downto 0);
    variable xin_v_vec : std_logic_vector(15 downto 0);
    variable yin_v : signed(15 downto 0);
    variable yin_v_vec : std_logic_vector(15 downto 0);
    variable zin_v : signed(15 downto 0);
    variable zin_v_vec : std_logic_vector(15 downto 0);
    variable xout_v, xout_ref : signed(15 downto 0);
    variable xout_v_vec, xout_ref_vec : std_logic_vector(15 downto 0);
    variable yout_v, yout_ref : signed(15 downto 0);
    variable yout_v_vec, yout_ref_vec : std_logic_vector(15 downto 0);
    variable zout_v, zout_ref : signed(15 downto 0);
    variable zout_v_vec, zout_ref_vec : std_logic_vector(15 downto 0);
    variable ncycles_v: integer;
    variable TestData, BufLine: line;
    variable Passed: std_logic := '1';
  begin
    while not endfile(TestDataFile) loop
      -- Read test data from file
      readline(TestDataFile, TestData);
      hread(TestData, direction_v_vec);
      direction <= direction_v_vec;
      hread(TestData, mode_v_vec);
      mode <= mode_v_vec;
      hread(TestData, xin_v_vec);
      xin <= xin_v_vec;
      hread(TestData, yin_v_vec);
      yin <= yin_v_vec;
      hread(TestData, zin_v_vec);
      zin <= zin_v_vec;
      hread(TestData, xout_ref_vec);
      xout_ref := SIGNED(xout_ref_vec);
      hread(TestData, yout_ref_vec);
      yout_ref := SIGNED(yout_ref_vec);
      hread(TestData, zout_ref_vec);
      zout_ref := SIGNED(zout_ref_vec);
      wait until done = '1';
      xout_v := signed(xout);
      yout_v := signed(yout);
      zout_v := signed(zout);
      -- Test CORDIC algorithm
      if (
          (xout_v /= xout_ref) or
          (yout_v /= yout_ref) or
          (zout_v /= zout_ref)
      ) then
        Passed := '0';
        write(Bufline, string'("CORDIC error: direction="));
        hwrite(Bufline, STD_LOGIC_VECTOR(direction));
        write(Bufline, string'("CORDIC error: mode="));
        hwrite(Bufline, STD_LOGIC_VECTOR(mode));
        write(Bufline, string'("CORDIC error: xin="));
        hwrite(Bufline, STD_LOGIC_VECTOR(xin));
        write(Bufline, string'("CORDIC error: yin="));
        hwrite(Bufline, STD_LOGIC_VECTOR(yin));
        write(Bufline, string'("CORDIC error: zin="));
        hwrite(Bufline, STD_LOGIC_VECTOR(zin));
        write(Bufline, string'(" xout="));
        hwrite(Bufline, STD_LOGIC_VECTOR(xout_v));
        write(Bufline, string'(" xout_ref="));
        hwrite(Bufline, STD_LOGIC_VECTOR(xout_ref));
        write(Bufline, string'(" yout="));
        hwrite(Bufline, STD_LOGIC_VECTOR(yout_v));
        write(Bufline, string'(" yout_ref="));
        hwrite(Bufline, STD_LOGIC_VECTOR(yout_ref));
        write(Bufline, string'(" zout="));
        hwrite(Bufline, STD_LOGIC_VECTOR(zout_v));
        write(Bufline, string'(" zout_ref="));
        hwrite(Bufline, STD_LOGIC_VECTOR(zout_ref));
        writeline(ResultsFile, Bufline);
      else
        write(Bufline, string'(" direction="));
        hwrite(Bufline, STD_LOGIC_VECTOR(direction));
        write(Bufline, string'(" mode="));
        hwrite(Bufline, STD_LOGIC_VECTOR(mode));
        write(Bufline, string'(" xin="));
        hwrite(Bufline, STD_LOGIC_VECTOR(xin));
        write(Bufline, string'(" yin="));
        hwrite(Bufline, STD_LOGIC_VECTOR(yin));
        write(Bufline, string'(" zin="));
        hwrite(Bufline, STD_LOGIC_VECTOR(zin));
        write(Bufline, string'(" xout="));
        hwrite(Bufline, STD_LOGIC_VECTOR(xout));
        write(Bufline, string'(" xout_ref="));
        hwrite(Bufline, STD_LOGIC_VECTOR(xout_ref));
        write(Bufline, string'(" yout="));
        hwrite(Bufline, STD_LOGIC_VECTOR(yout));
        write(Bufline, string'(" yout_ref="));
        hwrite(Bufline, STD_LOGIC_VECTOR(yout_ref));
        write(Bufline, string'(" zout="));
        hwrite(Bufline, STD_LOGIC_VECTOR(zout));
        write(Bufline, string'(" zout_ref="));
        hwrite(Bufline, STD_LOGIC_VECTOR(zout_ref));
        writeline(ResultsFile, Bufline);
        ncycles_v := ncycles;
        write(Bufline, string'("CORDIC OK: Number of cycles="));
        write(Bufline, ncycles_v);
        writeline(ResultsFile, Bufline);
      end if;
    end loop;
    if (Passed = '1') then
      write(Bufline, string'("CORDIC algorithm test has passed"));
      writeline(ResultsFile, Bufline);
      -- Automatic end of the current simulation.
      assert false
        report "End simulation time reached"
        severity failure;
    end if;
    wait for CLK_PERIOD;
  end process CORDIC_BENCH;

end tb_arch;
